## 1.4 依赖倒置原则
1.模块之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；即面向接口编程，面向抽象编程。
## 4原型模式
通过clone()来实现，它是Object中的方法，只有实现了Clonable的对象才能使用clone()方法，否则会抛异常。
通常分为浅克隆和深克隆，建议开发用深克隆(引用型字段也要拷贝page71)。克隆不会走构造方法（注意！！！）。
## 6抽象工厂
Android中使用的并不多，使用抽象工厂来创建对象，实现了接口与实现的分离
## 7策略模式
-针对同一类型问题的多种处理方式，仅仅具体行为有差别时。
-需要安全的封装多种同一种操作时。
-出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时。
## 8状态模式
与策略模式基本相同，不同之处在于策略倾向于封装方法，而状态倾向于区分不同的对象。
主要是用来减少if-else的使用
## 10解释器模式
使用比较少，一般用于解释文法规则，构建抽象语法树，了解即可。
## 11命令模式
将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化；对请求排队或者记录日志，以及支持可撤销的操作。
PS:抽取代码封装，然后添加功能
## 12观察者模式
AndroidEventBus项目地址为:https://github.com/bboyfeiyu/AndroidEventBus